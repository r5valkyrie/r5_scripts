global function SURVIVAL_Loot_All_InitShared

global function SURVIVAL_Loot_GetLootDataTable
global function SURVIVAL_Loot_GetLootDataByIndex
global function SURVIVAL_Loot_IsLootIndexValid
global function SURVIVAL_Loot_GetLootDataByRef
global function SURVIVAL_Loot_IsRefValid
global function SURVIVAL_Loot_IsRefDisabled
global function SURVIVAL_Loot_IsReforBaseWeaponDisabled
global function SURVIVAL_Loot_AddDisabledRef
global function SURVIVAL_Loot_GetByType
global function SURVIVAL_Loot_GetLootTypeFromString
global function SURVIVAL_Loot_GetAttachmentType_Enum
global function SURVIVAL_Loot_GetByTier
global function SURVIVAL_Loot_GetSortedStringArrayFromSupportedAttachmentsString
global function SURVIVAL_Loot_RegFromDataTable
global function FS_HaloSurvival_GetRandomItemFromPool

global function SURVIVAL_Loot_IsUniqueAmmoWeapon
global function GetCustomHopupArray
global function IsNewLootEnabled
global function IsEnabledForGroundLoot
global function GetLockedSetFromName

#if CLIENT || UI
global function AddCallback_EditLootDesc
global function RemoveCallback_EditLootDesc
#endif

#if CLIENT
global function GetRarityColor
#endif

#if CLIENT && DEVELOPER
global function DumpModdedKeyColors
global function DiffKeyColors
#endif

global function GetFXRarityColorForTier // use this for in game loot
global function GetFXRarityColorForUnlockable
global function IsCustomAttachment
global function IsCustomWeapon

//Mod registration functions
global function RegisterModWeapon
global function RegisterModHopup
global function RegisterModGrenade
global function RegisterModConsumable

//Ground loot control functions
global function AddItemToGroundLootExclusion
global function IsModItemExcludedFromGroundLoot

#if CLIENT || SERVER
global function SURVIVAL_Loot_IsAmmoSpawningDisabled
#endif

global function AddCallback_OnLootDatatablesLoaded

global enum eLootTier
{
	NONE
	COMMON
	RARE
	EPIC
	LEGENDARY
	HEIRLOOM

	_count
}

global struct LootData
{
	string        ref
	int           tier
	int           index = -1
	int           inventorySlotCount
	int           pingCommsAction
	asset         model
	int           skinOverride
	asset         hudIcon
	asset		  craftingIcon
	asset         emptyImage
	string        attachSound
	string        pickupSound_1p
	string        pickupSound_3p
	string        carrySound
	string        pickupString
	string        desc
	string        hopupPopupDesc
	string        specialCaseInvalidReason
	int           countPerDrop
	int           lootType
	string        netInt
	array<string> supportedAttachments
	array<string> disabledAttachments
	array<string> lootTags
	string        ammoType
	string        secondaryAmmoType
	bool          isActive = false
	int           passive = -1
	string        attachmentStyle = ""
	int 		  attachmentType = -1
	int           scrapValue
	bool          droppodRotate = false
	bool          isDynamic = false
	bool          conditional = false
	bool          printPickupToObituary = false
	bool          pretendsToBeBlank = false
	bool          noDrop = false

	table<int,var> extraData

	string        baseWeapon
	array<string> baseMods

	asset         fakeAmmoIcon
	array<string> fakeMods

	bool functionref( entity, entity, int ) extraCanUseFunction = null
}

global struct CustomHopupData
{
	string className,
	string displayName,
	string desc,
	int tier,
	asset icon,
	asset model = $"mdl/weapons_r5/loot/_master/w_loot_wep_mods_chip.rmdl",
	string attachmentSlot = "hopup",
	float lowWeight = 5.0,
	float medWeight = 10.0,
	float highWeight = 25.0
}

global struct CustomGrenadeData
{
	string className,
	int countPerDrop,
	int stackSize,
	int tier,
	float chance,
	float carePackageChance
}

global struct CustomWeaponData
{
	string className,
	int tier,
	array<string> baseMods,
	array<string> supportedAttachments,
	string pickupSound1p,
	string pickupSound3p,
	string weaponType,
	float lowWeaponChance,
	float medWeaponChance,
	float highWeaponChance,
	string hudIcon,
	string name,
	bool isCP
}

global enum eWeaponLockedSet
{
	INVALID,
	WHITESET,
	BLUESET,
	PURPLESET,
	GOLD
}

global enum eExtraDataType
{
	INT_ARMOR_EVO = 0,
	INT_ARMOR_SHIELDS
}
global enum eWeaponAttachmentType
{
	NONE = -1,
	MAG,
	SCOPE,
	BARREL,
	STOCK,
	HOPUP,
	_count
}


global enum eLootType
{
	INVALID
	MAINWEAPON // must match with LOOT_TYPE_MAINWEAPON in RUI
	AMMO // must match with LOOT_TYPE_AMMO in RUI
	HEALTH
	ARMOR
	INCAPSHIELD
	JUMPKIT
	ORDNANCE
	ATTACHMENT
	CUSTOMPICKUP
	BACKPACK
	HELMET
	BLANK
	DATAKNIFE
	SHIPKEYCARD
	RESOURCE
	GADGET
	MARVIN_ARM

	_count
}

global const int HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND = 3

#if(true)
global struct OverrideDeathBoxRUI_NetworkOptimizedStruct
{
	string name
	string hardware
	string playerID
	int    characterIndex
	int    skinIndex
	int    frameIndex
	int    stanceIndex
	int    firstBadgeIndex
	int    firstBadgeDataInt
	int    secondBadgeIndex
	int    secondBadgeDataInt
	int    thirdBadgeIndex
	int    thirdBadgeDataInt

	bool isValid = false
}
#endif


struct
{
	table< string, LootData > lootData
	array<string>             lootIndexToString
	bool                      initialized
	array<string>             disabledRefs
	array<string>             uniqueAmmoWeaponRefs
	array<CustomHopupData>	  customHopups = []

	#if(true)
		table<EHI, array< OverrideDeathBoxRUI_NetworkOptimizedStruct > > EHIToOverrideDeathBoxRUIProfilesTable
		table<string, EHI>                                               corpseToEHITable
		array< OverrideDeathBoxRUI_NetworkOptimizedStruct >              handcraftedProfiles
		array< OverrideDeathBoxRUI_NetworkOptimizedStruct >              handcraftedProfilesMasterList //
	#endif

	#if CLIENT || UI
	array<string functionref( string, entity , string)> editLootDescCallbacks
	#endif
	array<void functionref( )> lootDatatablesLoadedCallbacks
	
	#if(UI)
		bool                                                      overrideDeathBoxRUI_Initialized = false
		table<string, OverrideDeathBoxRUI_NetworkOptimizedStruct> overrideDeathBoxRUIProfilesTable
		int                                                       profilesSent = 0
	#endif
	
	bool ENABLE_DEFINED_SETS
	array<string> modItemsExcludedFromGroundLoot
	
	array<CustomWeaponData> CustomModWeapons
	array<CustomHopupData> CustomModHopups
	array<CustomGrenadeData> CustomModGrenades
	array<CustomGrenadeData> CustomModConsumables
} file



array<string> attachmentSortOrder = ["barrel", "mag", "sight", "grip", "hopup", "hopupMulti_a", "hopupMulti_b"]

array<CustomHopupData> function GetCustomHopupArray()
{
	return file.customHopups
} 

string function GetLootTableString( string ref, var datatable, int rowIndex, string columnName )
{
	string val = GetDataTableString( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarString( (ref + "_dt_override_" + columnName), val )
}


asset function GetLootTableAsset( string ref, var datatable, int rowIndex, string columnName )
{
	return GetDataTableAsset( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
}


int function GetLootTableInt( string ref, var datatable, int rowIndex, string columnName )
{
	int val = GetDataTableInt( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarInt( (ref + "_dt_override_" + columnName), val )
}


bool function GetLootTableBool( string ref, var datatable, int rowIndex, string columnName )
{
	bool val = GetDataTableBool( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarBool( (ref + "_dt_override_" + columnName), val )
}


float function GetLootTableFloat( string ref, var datatable, int rowIndex, string columnName )
{
	float val = GetDataTableFloat( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarFloat( (ref + "_dt_override_" + columnName), val )
}

	// Need these here so they get included in bulids

void function SURVIVAL_Loot_All_InitShared()
{
	file.ENABLE_DEFINED_SETS = GetCurrentPlaylistVarBool( "flowstate_enable_weapons_locked_sets", false )
	
	file.lootIndexToString.clear()
	file.lootData.clear()

	file.disabledRefs.clear()
	file.disabledRefs = split( GetCurrentPlaylistVarString( "survival_disabled_loot", " " ), " " )

	if (Playlist() == ePlaylists.survival_firingrange || Playlist() == ePlaylists.survival_training)
	{
		SURVIVAL_Loot_RegFromDataTable( GetDataTable( $"datatable/survival_loot_sdk_firingrange.rpak" ) )
	} 
	else
	{
		SURVIVAL_Loot_RegFromDataTable( GetDataTable( $"datatable/survival_loot_sdk.rpak" ) )
		
		foreach ( callbackFunc in file.lootDatatablesLoadedCallbacks ) //To load loot datatables from mods
			callbackFunc()
		
		RegisterCustomWeapons() //JANU's Framework - Load custom items from playlist.
		RegisterCustomModItems() //Items added from Mods. Similar to JANU's but from Mod Init scripts.
	}

	#if(UI)
		RegisterSignal( "GatherFriendInfo" )
		RegisterSignal( "GatheredEnoughFriendInfo" )
		SURVIVAL_UIInit_Override_DeathBox_RUI()
	#endif

	file.initialized = true
}

bool function IsEnabledForGroundLoot( string ref )
{
	//Check mod exclusions first
	if(IsModItemExcludedFromGroundLoot(ref))
		return false
	
	if( Playlist() == ePlaylists.fs_haloMod_survival )
	{
		switch( ref )
		{
			case "armor_pickup_lv2":
			case "armor_pickup_lv3":
			case "armor_pickup_lv5":
			case "armor_pickup_lv6":
			case "armor_pickup_lv7":
			
			return false
		}
	}
	
	return true
}

bool function IsNewLootEnabled( string ref )
{
	if( Playlist() == ePlaylists.fs_haloMod_survival )
	{
		switch( ref )
		{
			case "mp_weapon_energysword":

			return false
		}
	}
		
	switch( ref )
	{
		case "armor_pickup_lv4_all_fast":
			if( GetCurrentPlaylistVarBool( "flowstate_evo_shields", false ) )
				return false
			else
				return true
		break

		case "":
		//disabled until proper porting and fix
		case "mp_weapon_grenade_gravity":
		
		case "mp_weapon_flamethrower":
			if( !IsFlowstateActive() )
				return false
			else 
				return true
		break
		case "armor_pickup_lv0_evolving":
		case "armor_pickup_lv1_evolving":
		case "armor_pickup_lv2_evolving":
		case "armor_pickup_lv3_evolving":
		case "armor_pickup_lv5_evolving":
		case "hopup_smart_reload":
		case "hopup_dual_loader":
		
		return false
	}

	return true
}

bool function EnableWeaponsLockedSets( string ref )
{
	array<string> stripedref = split( ref, "_" )

	switch( stripedref[stripedref.len()-1] )
	{
		case "whiteset":
		case "blueset":
		case "purpleset":
		
		return file.ENABLE_DEFINED_SETS
	}
	
	return true
}

int function GetLockedSetFromName( string ref )
{
	array<string> stripedref = split( ref, "_" )

	switch( stripedref[stripedref.len()-1] )
	{
		case "whiteset":
			return eWeaponLockedSet.WHITESET
		case "blueset":
			return eWeaponLockedSet.BLUESET
		case "purpleset":
			return eWeaponLockedSet.PURPLESET
	}
	
	return eWeaponLockedSet.INVALID
}

void function SURVIVAL_Loot_RegFromDataTable(var dt)
{
	var attachmentTable = GetDataTable( $"datatable/weapon_mods_sdk.rpak" )
	if( Playlist() == ePlaylists.survival_firingrange ) 
		attachmentTable = GetDataTable( $"datatable/weapon_mods_sdk_firing_range.rpak" )
	
	int numRows = GetDatatableRowCount( dt )
	for ( int i = 0; i < numRows; i++ )
	{
		LootData data
		data.ref = GetDataTableString( dt, i, GetDataTableColumnByName( dt, "ref" ) )

		string featureFlagRef = GetLootTableString( data.ref, dt, i, "featureFlag" )
		if ( featureFlagRef != "" && !GetFeatureFlagByString( featureFlagRef ) )
		{
			//printf( "Skipping loot ref %s because feature flag %s is off.", data.ref, featureFlagRef )
			//printf( "Loot ref %s: feature flag %s is off", data.ref, featureFlagRef )
			continue
		}

		string pingCommsActionName = GetLootTableString( data.ref, dt, i, "pingCommsAction" )

		#if (SERVER || CLIENT)
			data.pingCommsAction = GetCommsActionEnumForName( pingCommsActionName )
		#endif

		string lootType = GetLootTableString( data.ref, dt, i, "type" )

		data.baseWeapon = GetLootTableString( data.ref, dt, i, "baseWeapon" )

		if ( data.baseWeapon == "" )
		{
			data.baseWeapon = data.ref
		}
		
		if( !IsNewLootEnabled( data.baseWeapon ) )
			continue
		
		if( !EnableWeaponsLockedSets( data.ref ) )
			continue
		
		data.fakeAmmoIcon = GetLootTableAsset( data.ref, dt, i, "fakeAmmoIcon" )
		//if (data.fakeAmmoIcon != "") printt("Fake ammo icon for", data.ref, "-", data.fakeAmmoIcon)

		data.baseMods = split( GetLootTableString( data.ref, dt, i, "baseMods" ), " " )
		data.model = GetLootTableAsset( data.ref, dt, i, "pickupModel" )
		data.skinOverride = GetLootTableInt( data.ref, dt, i, "skinOverride" )
		data.hudIcon = GetLootTableAsset( data.ref, dt, i, "icon" )
		data.attachSound = GetLootTableString( data.ref, dt, i, "attachSound" )
		data.pickupSound_3p = GetLootTableString( data.ref, dt, i, "pickupSound_3p" )
		data.pickupSound_1p = GetLootTableString( data.ref, dt, i, "pickupSound_1p" )
		data.carrySound = GetLootTableString( data.ref, dt, i, "carrySound" )
		data.scrapValue = GetLootTableInt( data.ref, dt, i, "scrapValue" )
		data.droppodRotate = GetLootTableBool( data.ref, dt, i, "droppodRotate" )
		data.isDynamic = GetLootTableBool( data.ref, dt, i, "isDynamic" )
		data.conditional = GetLootTableBool( data.ref, dt, i, "conditional" )
		data.inventorySlotCount = GetLootTableInt( data.ref, dt, i, "inventorySlotCount" )
		data.countPerDrop = GetLootTableInt( data.ref, dt, i, "countPerDrop" )
		data.pickupString = GetLootTableString( data.ref, dt, i, "pickupString" )
		data.desc = GetLootTableString( data.ref, dt, i, "desc" )		
		data.tier = GetLootTableInt( data.ref, dt, i, "tier" )
		string supportedAttachmentsString  = GetLootTableString( data.ref, dt, i, "supportedAttachments" )
		array<string> supportedAttachments = split( supportedAttachmentsString, " " )
		supportedAttachments.sort(
			int function( string attachmentA, string attachmentB ) : ()
			{
				int aIndex = attachmentSortOrder.find( attachmentA )
				int bIndex = attachmentSortOrder.find( attachmentB )
				if ( aIndex > bIndex )
					return 1
				else if ( aIndex < bIndex )
					return -1

				return 0
			}
		)
		data.supportedAttachments = supportedAttachments

		//printt(data.ref, "| model:", string(GetLootTableAsset( data.ref, dt, i, "pickupModel" )))
		data.lootTags = split( GetLootTableString( data.ref, dt, i, "lootTags" ), " " )

		data.lootType = SURVIVAL_Loot_GetLootTypeFromString( lootType )
		data.netInt = GetLootTableString( data.ref, dt, i, "netInt" )

		string passiveRef = GetLootTableString( data.ref, dt, i, "passive" )
		if ( passiveRef == "" )
		{
			data.passive = ePassives.INVALID
		}
		else
		{
			Assert( passiveRef in ePassives )
			data.passive = ePassives[passiveRef]
			#if CLIENT || UI
				Assert( data.passive in PASSIVE_NAME_MAP )
				Assert( data.passive in PASSIVE_DESCRIPTION_SHORT_MAP )
			#endif
		}
		
		switch ( data.lootType )
		{
			case eLootType.MAINWEAPON:
				RegisterWeaponForUse( data.baseWeapon )
				RegisterCustomAttachments(GetCustomHopupsForWeapon(data.baseWeapon))
				data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
				data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
				data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
				data.model = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "playermodel" )
				if ( GetWeaponInfoFileKeyField_Global( data.baseWeapon, "ammo_pool_type" ) != null )
					data.ammoType = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "ammo_pool_type" )
				else
					data.ammoType = ""

				if ( data.fakeAmmoIcon != "" )
				{
					file.uniqueAmmoWeaponRefs.append( data.ref )
				}

				ItemFlavor ornull weaponFlavor = GetWeaponItemFlavorByClass( data.baseWeapon )
				if ( weaponFlavor != null )
				{
					expect ItemFlavor( weaponFlavor )

					int availableState = ItemFlavor_GetPlaylistOpinion( weaponFlavor )
					bool shouldBeEnabled
					if ( availableState == eItemFlavorPlaylistOpinion.FORCE_UNLOCK_FOR_SPECIAL_EVENT )
						shouldBeEnabled = true
					else if ( availableState == eItemFlavorPlaylistOpinion.HIDDEN )
						shouldBeEnabled = false
					else if ( availableState == eItemFlavorPlaylistOpinion.DISABLED )
						shouldBeEnabled = false
					else
						shouldBeEnabled = ItemFlavor_IsActiveForEdition( weaponFlavor, GetConVarInt( "mtx_svEdition" ) )

					if ( !shouldBeEnabled )
						file.disabledRefs.append( data.ref )
				}
				break

			case eLootType.ORDNANCE:
				RegisterWeaponForUse( data.baseWeapon )
				data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
				data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
				data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
				break

			case eLootType.AMMO:
				data.countPerDrop = int( GetCurrentPlaylistVarFloat( "loot_ammo_scale_per_drop", 1.0 ) * float( data.countPerDrop ) )
				data.inventorySlotCount = int( GetCurrentPlaylistVarFloat( "inventory_ammo_scale_stacksize", 1.0 ) * float( data.inventorySlotCount ) )
				break

			case eLootType.ATTACHMENT:
				int row = GetDataTableRowMatchingStringValue( attachmentTable, GetDataTableColumnByName( attachmentTable, "mod" ), data.ref )
				data.pickupString = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "name" ) )
				data.desc = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "description" ) )

				data.ammoType = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "ammoType" ) )
				data.hudIcon = GetLootTableAsset( data.ref, dt, i, "icon" )
				data.specialCaseInvalidReason = ""//
				if ( data.hudIcon == $"" )
					data.hudIcon = GetDataTableAsset( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "image" ) )

				string attachmentPoint = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "attachmentPoint" ) )
				data.attachmentStyle = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "type" ) )
				data.emptyImage = GetDataTableAsset( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "emptyImage" ) )

				#if SERVER || CLIENT
				RegisterAttachmentPoint( attachmentPoint )
				#endif
				break
		}

		//Save
		{
			data.index = file.lootIndexToString.len()
			file.lootIndexToString.append( data.ref )
			
			file.lootData[ data.ref ] <- data

			#if SERVER
				SURVIVAL_AddSpawnPointGroup( data.ref )
			#endif
		}

		#if !UI
			if ( data.model != $"" )
				PrecacheModel( data.model )
		#endif
	}

	#if(UI)
		RegisterSignal( "GatherFriendInfo" )
		RegisterSignal( "GatheredEnoughFriendInfo" )
		SURVIVAL_UIInit_Override_DeathBox_RUI()
	#endif
}


void function RegisterCustomWeapons()
{
	array<string> customWeaponClassNames = split(GetCurrentPlaylistVarString("custom_weapon_list", ""), " ")
	
	#if DEVELOPER //(mk): added for confirmation, added hudIcon, added name, added registering damagedef	
		
		int customWepCount = customWeaponClassNames.len()
		
		if ( customWepCount > 0 )
		{
			string pr = "\n\n ---- customWeaponClassNames ---- \n\n"
			foreach( item in customWeaponClassNames )
			{
				pr += item + "\n"
			}
			printt( pr )
		}
		printt( "customWeaponClassNames count: ", customWepCount )	
		
	#endif 
	
	foreach (string className in customWeaponClassNames)
	{
		CustomWeaponData data
		// Class name - the file name of the weapon, excluding extension
		data.className = className
		// Tier - the displayed rarity of the weapon
		data.tier = GetCurrentPlaylistVarInt(className + "_tier", 1)
		// equip these mods on pickup.
		data.baseMods = split(GetCurrentPlaylistVarString(className + "_base_mods", ""), " ")
		// what attachments does the weapon support
		data.supportedAttachments = split(GetCurrentPlaylistVarString(className + "_attachments", "barrel mag sight grip"), " ")
		// pickup sounds
		data.pickupSound1p = GetCurrentPlaylistVarString(className + "_pickup_sound_1p", "survival_loot_pickup_weapon_rspn101")
		data.pickupSound3p = GetCurrentPlaylistVarString(className + "_pickup_sound_3p", "survival_loot_pickup_3p_weapon_rspn101")
		// weapon type - used for attachments.
		// weaponTypes: assault, smg, lmg, sniper, shotgun, pistol
		data.weaponType = GetCurrentPlaylistVarString(className + "_class", "assault")
		// weights for weapon to appear on ground.
		// the game sets the chances to a sum of 100 normally.
		// the actual chance is dependent on all other weapons.
		data.lowWeaponChance = GetCurrentPlaylistVarFloat(className + "_low_chance", 0.0 ) //5.0)
		data.medWeaponChance = GetCurrentPlaylistVarFloat(className + "_med_chance", 0.0 ) // 10.0)
		data.highWeaponChance = GetCurrentPlaylistVarFloat(className + "_high_chance", 0.0 ) // 25.0)
		
		data.hudIcon =	GetCurrentPlaylistVarString(className + "_hud_icon", "$\"\"" )
		data.name = GetCurrentPlaylistVarString(className + "_name", "Custom Weapon" )
		
		data.isCP = GetCurrentPlaylistVarBool(className + "_cp_weapon", false)
		RegisterWeapon(data)
		// RegisterCustomAttachments(GetCustomHopupsForWeapon(className))
	}
	
	array<string> customHopupsClassNames = split(GetCurrentPlaylistVarString("custom_hopup_list", ""), " ")
	RegisterCustomAttachments(customHopupsClassNames)
	
	array<string> customGrenadeClassNames = split(GetCurrentPlaylistVarString("custom_grenade_list", ""), " ")
	foreach(string className in customGrenadeClassNames)
	{
		CustomGrenadeData data
		data.className = className
		data.countPerDrop = GetCurrentPlaylistVarInt(className + "_count_per_drop", 1)
		data.stackSize = GetCurrentPlaylistVarInt(className + "_stack_size", 2)
		data.tier = GetCurrentPlaylistVarInt(className + "_tier", 1)
		data.chance = GetCurrentPlaylistVarFloat(className + "_chance", 0)
		data.carePackageChance = GetCurrentPlaylistVarFloat(className + "_cp_chance", 0)
		RegisterCustomGrenade(data)
	}

	array<string> customConsumableClassNames = split(GetCurrentPlaylistVarString("custom_consumable_list", ""), " ")
	foreach(string className in customConsumableClassNames)
	{
		printt("CLASS NAME:", className)
		CustomGrenadeData data
		data.className = className
		data.countPerDrop = GetCurrentPlaylistVarInt(className + "_count_per_drop", 1)
		data.stackSize = GetCurrentPlaylistVarInt(className + "_stack_size", 2)
		data.tier = GetCurrentPlaylistVarInt(className + "_tier", 1)
		data.chance = GetCurrentPlaylistVarFloat(className + "_chance", 0)
		data.carePackageChance = GetCurrentPlaylistVarFloat(className + "_cp_chance", 0)
		RegisterCustomConsumable(data)
	}
	
	#if SERVER
		AddClientCommandCallback( "SetNextCustomConsumable", ClientCallback_SetNextCustomConsumable )
	#endif
}

bool function IsCustomAttachment(LootData data)
{
	//printt(data.ref)
	foreach (CustomHopupData d in file.customHopups)
	{
		if (d.className == data.ref) return true
	}
	return false
}

bool function IsCustomWeapon(LootData data)
{
	var weaponMatrix = GetDataTable( $"datatable/weapon_attachment_matrix.rpak" )

	int col = GetDataTableColumnByName( weaponMatrix, data.baseWeapon )

	return col == -1
}

void function RegisterCustomAttachments(array<string> refs)
{
	foreach(string className in refs){
		CustomHopupData data
		// class name - the name of the mod to be added to a weapon once this hopup is equipped.
		data.className = className
		// display name - the name displayed on pop-ups of this hop-up.
		data.displayName = GetCurrentPlaylistVarString(className + "_name", "Custom Hopup")
		// description.
		data.desc = GetCurrentPlaylistVarString(className + "_desc", "Hop up desc")
		// Tier - the displayed rarity of the hop-up
		data.tier = GetCurrentPlaylistVarInt(className + "_tier", 1)
		// icon - the icon of the hop-up. defaults to the Choke Hop-up Icon.
		#if !UI
		data.icon = CastStringToAsset(GetCurrentPlaylistVarString(className + "_icon", "rui/pilot_loadout/mods/hopup_em_choke"))
		// model - the appearance of the hop-up on the ground.
		data.model = CastStringToAsset(GetCurrentPlaylistVarString(className + "_model", "mdl/weapons_r5/loot/_master/w_loot_wep_mods_chip.rmdl"))
		#endif
		// The weight of the hop-up in Basic Tier Loot areas
		data.lowWeight = GetCurrentPlaylistVarFloat(className + "_low_chance", 5.0)
		// The weight of the hop-up in Mid Tier Loot areas
		data.medWeight = GetCurrentPlaylistVarFloat(className + "_med_chance", 10.0)
		// The weight of the hop-up in High Tier Loot areas
		data.highWeight = GetCurrentPlaylistVarFloat(className + "_high_chance", 25.0)
		// slot
		data.attachmentSlot = GetCurrentPlaylistVarString(className + "_slot", "hopup")
		// create the hopup...
		CreateCustomHopup(data)
	}
}

array<string> function GetCustomHopupsForWeapon(string className)
{
	array<string> result = []
	foreach(string mod in GetWeaponMods_Global(className))
	{
		if (SURVIVAL_Loot_IsRefValid(mod)) continue;

		if (GetCurrentPlaylistVarString(mod + "_slot", "") == "") continue;
		result.append(mod)
	}
	return result
}

void function RegisterCustomGrenade(CustomGrenadeData grenadeData) {
	LootData data
	data.ref = grenadeData.className
	data.baseWeapon = grenadeData.className
	#if !UI
	PrecacheWeapon( data.baseWeapon )
	#endif
	data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
	data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
	data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
	data.model = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "playermodel" )
	data.tier = grenadeData.tier
	data.countPerDrop = grenadeData.countPerDrop
	data.inventorySlotCount = grenadeData.stackSize
	data.lootType = eLootType.ORDNANCE
	data.pickupSound_1p = "survival_loot_pickup_ordanance"
	data.pickupSound_3p = "survival_loot_pickup_3p_ordanance"

	data.index = file.lootIndexToString.len()
	file.lootIndexToString.append( data.ref )
	file.lootData[ data.ref ] <- data

	#if !UI
	AddCustomItemToLootPool( data.ref, "ordnance", grenadeData.chance)
	AddCustomItemToLootPool( data.ref, "ordnance_drops", grenadeData.carePackageChance)
	#endif
}

void function RegisterCustomConsumable(CustomGrenadeData grenadeData)
{
	LootData data
	data.ref = grenadeData.className
	data.baseWeapon = grenadeData.className
	#if !UI
		PrecacheWeapon( data.baseWeapon )
	#endif
	data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
	data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
	data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
	// this is so playermodel can still be empty handed if we choose so.
	data.model = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "pickupmodel" )
	data.tier = grenadeData.tier
	data.countPerDrop = grenadeData.countPerDrop
	data.inventorySlotCount = grenadeData.stackSize
	data.lootType = eLootType.CUSTOMPICKUP
	data.pickupSound_1p = "survival_loot_pickup_ordanance"
	data.pickupSound_3p = "survival_loot_pickup_3p_ordanance"

	data.index = file.lootIndexToString.len()
	file.lootIndexToString.append( data.ref )
	file.lootData[ data.ref ] <- data
	#if CLIENT
		RegisterUseFunctionForItem( data.ref, FireCustomConsumable )
	#endif

	#if !UI
	AddCustomItemToLootPool( data.ref, "ordnance", grenadeData.chance)
	AddCustomItemToLootPool( data.ref, "ordnance_drops", grenadeData.carePackageChance)
	#endif
}

void function RegisterCustomModItems()
{
	foreach( weapon in file.CustomModWeapons )
		RegisterWeapon( weapon )
		
	foreach( hopup in file.CustomModHopups )
		CreateCustomHopup( hopup )
	
	foreach( grenade in file.CustomModGrenades )
		RegisterCustomGrenade( grenade )
	
	foreach( consumable in file.CustomModConsumables )
		RegisterCustomConsumable( consumable )	
}

//Mod registration utility functions for mods to use without playlist dependencies
void function RegisterModWeapon(CustomWeaponData weaponData, bool enableGroundLoot = true)
{
	//Validate required fields
	if(weaponData.className == "")
	{
		#if DEVELOPER
			printw("[MOD WEAPON] Error: Weapon className cannot be empty")
		#endif
		return
	}
	
	//Set default values for optional fields
	if(weaponData.name == "")
		weaponData.name = "Custom Weapon"
	if(weaponData.hudIcon == "")
		weaponData.hudIcon = "$\"\""
	if(weaponData.weaponType == "")
		weaponData.weaponType = "assault"
	if(weaponData.pickupSound1p == "")
		weaponData.pickupSound1p = "survival_loot_pickup_weapon_rspn101"
	if(weaponData.pickupSound3p == "")
		weaponData.pickupSound3p = "survival_loot_pickup_3p_weapon_rspn101"
	if(weaponData.tier == 0)
		weaponData.tier = eLootTier.COMMON
	if(weaponData.supportedAttachments.len() == 0)
		weaponData.supportedAttachments = ["barrel", "mag", "sight", "grip"]
	
	#if DEVELOPER
		printt("[MOD WEAPON] Registering weapon:", weaponData.className, "- Name:", weaponData.name, "- Ground Loot:", enableGroundLoot)
	#endif
	
	//Handle ground loot exclusion
	if(!enableGroundLoot)
		AddItemToGroundLootExclusion(weaponData.className)
	
	file.CustomModWeapons.append( weaponData )
}

void function RegisterModHopup(CustomHopupData hopupData, bool enableGroundLoot = true)
{
	//Validate required fields
	if(hopupData.className == "")
	{
		#if DEVELOPER
			printw("[MOD HOPUP] Error: Hopup className cannot be empty")
		#endif
		return
	}
	
	//Set default values for optional fields
	if(hopupData.displayName == "")
		hopupData.displayName = "Custom Hopup"
	if(hopupData.desc == "")
		hopupData.desc = "Custom hop-up description"
	if(hopupData.tier == 0)
		hopupData.tier = eLootTier.COMMON
	if(hopupData.attachmentSlot == "")
		hopupData.attachmentSlot = "hopup"
	
	#if DEVELOPER
		printt("[MOD HOPUP] Registering hopup:", hopupData.className, "- Name:", hopupData.displayName, "- Ground Loot:", enableGroundLoot)
	#endif
	
	//Handle ground loot exclusion
	if(!enableGroundLoot)
		AddItemToGroundLootExclusion(hopupData.className)
	
	file.CustomModHopups.append( hopupData )
}

void function RegisterModGrenade(CustomGrenadeData grenadeData, bool enableGroundLoot = true)
{
	//Validate required fields
	if(grenadeData.className == "")
	{
		#if DEVELOPER
			printw("[MOD GRENADE] Error: Grenade className cannot be empty")
		#endif
		return
	}
	
	//Set default values for optional fields
	if(grenadeData.tier == 0)
		grenadeData.tier = eLootTier.COMMON
	if(grenadeData.countPerDrop == 0)
		grenadeData.countPerDrop = 1
	if(grenadeData.stackSize == 0)
		grenadeData.stackSize = 2
	
	#if DEVELOPER
		printt("[MOD GRENADE] Registering grenade:", grenadeData.className, "- Ground Loot:", enableGroundLoot)
	#endif
	
	//Handle ground loot exclusion
	if(!enableGroundLoot)
		AddItemToGroundLootExclusion(grenadeData.className)
	
	file.CustomModGrenades.append( grenadeData )
}

void function RegisterModConsumable(CustomGrenadeData consumableData, bool enableGroundLoot = true)
{
	//Validate required fields
	if(consumableData.className == "")
	{
		#if DEVELOPER
			printw("[MOD CONSUMABLE] Error: Consumable className cannot be empty")
		#endif
		return
	}
	
	//Set default values for optional fields
	if(consumableData.tier == 0)
		consumableData.tier = eLootTier.COMMON
	if(consumableData.countPerDrop == 0)
		consumableData.countPerDrop = 1
	if(consumableData.stackSize == 0)
		consumableData.stackSize = 2
	
	#if DEVELOPER
		printt("[MOD CONSUMABLE] Registering consumable:", consumableData.className, "- Ground Loot:", enableGroundLoot)
	#endif
	
	//Handle ground loot exclusion
	if(!enableGroundLoot)
		AddItemToGroundLootExclusion(consumableData.className)
	
	file.CustomModConsumables.append( consumableData )
}

//Ground loot control functions
void function AddItemToGroundLootExclusion(string itemRef)
{
	if(!file.modItemsExcludedFromGroundLoot.contains(itemRef))
	{
		file.modItemsExcludedFromGroundLoot.append(itemRef)
		#if DEVELOPER
			printt("[GROUND LOOT] Excluded item from ground loot:", itemRef)
		#endif
	}
}

bool function IsModItemExcludedFromGroundLoot(string itemRef)
{
	return file.modItemsExcludedFromGroundLoot.contains(itemRef)
}

#if CLIENT
void function FireCustomConsumable(entity player, string ref)
{
	player.ClientCommand( "SetNextCustomConsumable " + ref )
	ActivateOffhandWeaponByIndex(OFFHAND_EQUIPMENT)
}
#endif

array<string> function SURVIVAL_Loot_GetSortedStringArrayFromSupportedAttachmentsString( string supportedAttachmentsString )
{
	array<string> supportedAttachments = split( supportedAttachmentsString, WHITESPACE_CHARACTERS )
	supportedAttachments.sort(
		int function( string attachmentA, string attachmentB ) : ()
		{
			int aIndex = attachmentSortOrder.find( attachmentA )
			int bIndex = attachmentSortOrder.find( attachmentB )
			if ( aIndex > bIndex )
				return 1
			else if ( aIndex < bIndex )
				return -1

			return 0
		}
	)
	return supportedAttachments
}

#if SERVER
bool function ClientCallback_SetNextCustomConsumable( entity player, array<string> args )
{
	if (!SURVIVAL_Loot_IsRefValid(args[0])) return true
	if (SURVIVAL_CountItemsInInventory(player, args[0]) <= 0) return true

	printt("setting next consumable: ", args[0])
	
	if (IsValid(player.GetOffhandWeapon(OFFHAND_EQUIPMENT)) && player.GetOffhandWeapon(OFFHAND_EQUIPMENT).GetWeaponClassName() != args[0])
	{
		player.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
		player.GiveOffhandWeapon( args[0], OFFHAND_EQUIPMENT )
	}
	else if (!IsValid(player.GetOffhandWeapon(OFFHAND_EQUIPMENT))) 
	{
		player.GiveOffhandWeapon( args[0], OFFHAND_EQUIPMENT )
	}
	return true
}
#endif

void function RegisterWeapon( CustomWeaponData weaponData )
{
	LootData data
	
	data.ref = weaponData.className
	// have no idea why we do this, but it's needed.
	data.baseWeapon = weaponData.className

	// We don't use this as custom weapons don't have an eDamageSourceId.
	// This means that kills with the weapon will show up as
	// Attacker [Killed] Victim.
	// This would be nice if changed, but it's good as is for now,
	// as the game is not fully functioning yet.
	//RegisterWeaponForUse( data.baseWeapon )

	// precache the weapon, obviously.
	#if !UI
		PrecacheWeapon(weaponData.className)
		RegisterCustomWeaponDamageDef( weaponData.className, weaponData.name, weaponData.hudIcon ) //~mkos
		//RegisterCustomWeaponDamageSource(weaponData.className)
	#endif
	// rarity
	data.tier = weaponData.tier
	// Copy pasted from SURVIVAL_Loot_All_InitShared
	data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
	data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
	data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
	data.model = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "playermodel" )
	data.countPerDrop = 1

	// Pickup sounds. 
	data.pickupSound_3p = weaponData.pickupSound3p
	data.pickupSound_1p = weaponData.pickupSound1p
	// Ammo type - also will FINALLY show up on HUD when you equip the weapon :D
	if ( GetWeaponInfoFileKeyField_Global( data.baseWeapon, "ammo_pool_type" ) != null )
		data.ammoType = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "ammo_pool_type" )

	// loot tags is just weapon type in disguise.
	data.lootTags = [ weaponData.weaponType ]
	data.lootType = eLootType.MAINWEAPON
	
	// sort the attachments so it appears like vanilla and not messed up
	// if it's typed incorrectly in playlists
	weaponData.supportedAttachments.sort(
		int function( string attachmentA, string attachmentB ) : ()
		{
			int aIndex = attachmentSortOrder.find( attachmentA )
			int bIndex = attachmentSortOrder.find( attachmentB )
			if ( aIndex > bIndex )
				return 1
			else if ( aIndex < bIndex )
				return -1
			return 0
		}
	)
	
	data.supportedAttachments = weaponData.supportedAttachments
	// base mods, come with the weapon.
	data.baseMods = weaponData.baseMods
	
	// index goes above 100 with custom items, this is why we extended the remote function.
	data.index = file.lootIndexToString.len()
	file.lootIndexToString.append( data.ref )
	file.lootData[ data.ref ] <- data

	#if SERVER
		SURVIVAL_AddSpawnPointGroup( data.ref )
	#endif
	
	#if !UI
		if ( data.model != $"" )
			PrecacheModel( data.model )
		// Add the item to the loot pool
		if (!weaponData.isCP)
		{
			AddCustomItemToLootPool(data.ref, "weapon_low", weaponData.lowWeaponChance)
			AddCustomItemToLootPool(data.ref, "weapon_medium", weaponData.medWeaponChance)
			AddCustomItemToLootPool(data.ref, "weapon_high", weaponData.highWeaponChance)
		}
		else 
		{
			AddCustomItemToLootPool(data.ref, "crate_weapons_earlygame", weaponData.lowWeaponChance)
			AddCustomItemToLootPool(data.ref, "crate_weapons_midgame", weaponData.medWeaponChance)
			AddCustomItemToLootPool(data.ref, "crate_weapons_lategame", weaponData.highWeaponChance)
		}
	#endif
	// Not needed to appear in the dev menu.
	//#if CLIENT
	//RunUIScript( "SetupDevCommand", "Spawn " + data.pickupString, "script SpawnGenericLoot( \"" + data.ref + "\", gp()[0].GetOrigin(), <-1,-1,-1>, 1 )" )
	//#endif
	
	#if DEVELOPER && !UI//(mk): added for modders' sanity
	printf("\n\n --- Registered Custom Weapon as --- \n\n className: %s \n name: %s \n tier: %d \n baseMods: %s \n supportedAttachments: %s \n pickupSound1p: %s \n pickupSound3p: %s \n weaponType: %s \n lowWeaponChance: %.2f \n medWeaponChance: %.2f \n highWeaponChance: %.2f \n hudIcon: %s ",
			weaponData.className,
			weaponData.name,
			weaponData.tier,
			ArrayToString( weaponData.baseMods ),
			ArrayToString( weaponData.supportedAttachments ),
			weaponData.pickupSound1p,
			weaponData.pickupSound3p,
			weaponData.weaponType,
			weaponData.lowWeaponChance,
			weaponData.medWeaponChance,
			weaponData.highWeaponChance,
			weaponData.hudIcon
		)
	#endif
}

void function CreateCustomHopup(CustomHopupData hopupData)
{
	LootData data

	data.ref = hopupData.className
	data.pickupString = hopupData.displayName
	data.desc = hopupData.desc
	data.hudIcon = hopupData.icon
	data.model = hopupData.model
	data.tier = hopupData.tier

	// can be hardcoded since this is an attachment, no need for custom pickup sounds.
	data.pickupSound_1p = "survival_loot_pickup_attachments"
	data.pickupSound_3p = "survival_loot_pickup_3p_attachments"

	// needs to be setup, otherwise you won't be able to pick up the attachment
	data.countPerDrop = 1
	data.inventorySlotCount = 1
	data.attachmentStyle = "hopup"

	data.lootTags = []
	data.lootType = eLootType.ATTACHMENT


	// index goes above 100 with custom items, this is why we extended the remote function.
	data.index = file.lootIndexToString.len()
	file.lootIndexToString.append( data.ref )
	file.lootData[ data.ref ] <- data

	#if !UI
		// add custom item to loot pool.
		AddCustomItemToLootPool(data.ref, "attachment_low", hopupData.lowWeight)
		AddCustomItemToLootPool(data.ref, "attachment_medium", hopupData.medWeight)
		AddCustomItemToLootPool(data.ref, "attachment_high", hopupData.highWeight)
	#endif
	file.customHopups.append(hopupData)
}

table< string, LootData > function SURVIVAL_Loot_GetLootDataTable()
{
	return file.lootData
}

LootData function FS_HaloSurvival_GetRandomItemFromPool()
{
	return file.lootData[ file.lootIndexToString[ RandomIntRangeInclusive( 0, file.lootIndexToString.len() - 1 ) ] ]
}

array<LootData> function SURVIVAL_Loot_GetByType( int lootType )
{
	array<LootData> lootOfType = []
	foreach ( string lootRef, LootData lootData in file.lootData )
	{
		if ( lootData.lootType != lootType )
			continue

		lootOfType.append( lootData )
	}

	return lootOfType
}


array<LootData> function SURVIVAL_Loot_GetByTier( int tier, bool addWeapons = true )
{
	array<LootData> lootOfTier = []
	foreach ( string lootRef, LootData lootData in file.lootData )
	{
		if ( lootData.tier!= tier )
			continue

		if ( SURVIVAL_Loot_IsRefDisabled( lootData.ref ) )
			continue
		
		if( !addWeapons && lootData.lootType == eLootType.MAINWEAPON )
			continue
		//printt( lootData.ref )

		lootOfTier.append( lootData )
	}

	return lootOfTier
}

int function SURVIVAL_Loot_GetLootTypeFromString( string lootTypeString )
{
	Assert( lootTypeString != "", "Loot Type has null type defined in survival_loot.csv" )

	switch( lootTypeString )
	{
		case "main_weapon":
			return eLootType.MAINWEAPON

		case "ammo":
			return eLootType.AMMO

		case "health":
			return eLootType.HEALTH

		case "armor":
			return eLootType.ARMOR

		case "incapshield":
			return eLootType.INCAPSHIELD

		case "jumpkit":
			return eLootType.JUMPKIT

		case "ordnance":
			return eLootType.ORDNANCE

		case "attachment":
			return eLootType.ATTACHMENT

		case "backpack":
			return eLootType.BACKPACK

		case "custom_pickup":
		case "bomb":
			return eLootType.CUSTOMPICKUP

		case "helmet":
			return eLootType.HELMET

		case "data_knife":
			return eLootType.DATAKNIFE
			
		case "ship_keycard":
			return eLootType.SHIPKEYCARD

		case "blank":
			return eLootType.BLANK

		case "resource":
			return eLootType.RESOURCE
			
		case "gadget":
			return eLootType.GADGET
			
		case "marvin_arm":
			return eLootType.MARVIN_ARM

		default:
			//
			Warning( "Error Building LootData Struct: Unknown loot type string: " + lootTypeString )
			return eLootType.BLANK
	}

	unreachable
}

int function SURVIVAL_Loot_GetAttachmentType_Enum( string attachmentType )
{
	int attachmentStyle = eWeaponAttachmentType.NONE
	switch( attachmentType )
	{
		case "mag":
			attachmentStyle = eWeaponAttachmentType.MAG
			break
		case "sight":
			attachmentStyle = eWeaponAttachmentType.SCOPE
			break
		case "barrel":
			attachmentStyle = eWeaponAttachmentType.BARREL
			break
		case "grip":
		case "stock":
			attachmentStyle = eWeaponAttachmentType.STOCK
			break
		case "hopup":
			attachmentStyle = eWeaponAttachmentType.HOPUP
			break
		default:
			break
	}
	return attachmentStyle
}

LootData function SURVIVAL_Loot_GetLootDataByIndex( int index )
{
	#if CLIENT
	try
	{
		return file.lootData[ file.lootIndexToString[ index ] ]
	}
	catch (error)
	{
		RunUIScript("OpenErrorDialog", "Client loot table out of sync (code:items)\n\nMake sure you have R5Reloaded and Flowstate updated.")
		GetLocalClientPlayer().ClientCommand("disconnect")
		printt(error)
		return file.lootData[ file.lootIndexToString[0] ]
	}
	unreachable
	#else
	// Server is always right, therefore this must exist.
	return file.lootData[ file.lootIndexToString[ index ] ]
	#endif
}
bool function SURVIVAL_Loot_IsLootIndexValid( int index )
{
	return ( index in file.lootIndexToString )
}
LootData function SURVIVAL_Loot_GetLootDataByRef( string ref )
{
	return file.lootData[ ref ]
}
bool function SURVIVAL_Loot_IsRefValid( string ref )
{
	return (ref in file.lootData)
}

bool function SURVIVAL_Loot_IsRefDisabled( string ref )
{
	return file.disabledRefs.contains( ref )
}

bool function SURVIVAL_Loot_IsReforBaseWeaponDisabled( string ref )
{
	if( SURVIVAL_Loot_IsRefDisabled( ref ) )
		return true
	// If it's not valid, lets consider it disabled
	if( !SURVIVAL_Loot_IsRefValid( ref ) )
		return true
	// If the base weapon is disabled, disable all derived locked sets
	LootData lootData = SURVIVAL_Loot_GetLootDataByRef( ref )
                     
                                                         
               
       
	if( lootData.lootType == eLootType.MAINWEAPON && SURVIVAL_Loot_IsRefDisabled( lootData.baseWeapon ) )
		return true
	return false
}
void function SURVIVAL_Loot_AddDisabledRef( string ref )
{
	if ( !file.disabledRefs.contains( ref ) )
	{
		file.disabledRefs.append( ref )
	}
}
#if DEVELOPER
void function DEV_PrintDisabledLoot()
{
	printf("Dumping Disabled Loot")
	foreach ( string ref in file.disabledRefs )
	{
		printf( ref )
	}
}
#endif//DEVELOPER
#if CLIENT
vector function GetRarityColor( entity ent )
{
	int lootIndex = ent.GetSurvivalInt()
	Assert( lootIndex >= 0 )
	LootData lootData = SURVIVAL_Loot_GetLootDataByIndex( lootIndex )

	switch ( lootData.tier )
	{
		case 6:
			return <36, 194, 25>
			
		case 7:
			return <191, 25, 194>

		default:
			return GetKeyColor( COLORID_FX_LOOT_TIER0, lootData.tier )
	}
	
	unreachable
}
#endif

#if SERVER
//HACK: Resurrection of loot color consts for when the server picks a color
const int RARE_R = 58
const int RARE_G = 133
const int RARE_B = 176

const int EPIC_R = 136
const int EPIC_G = 63
const int EPIC_B = 162

const int LEGENDARY_R = 220
const int LEGENDARY_G = 185
const int LEGENDARY_B = 39

const vector LOOT_COLOR_NONE = <0, 0, 0>
const vector LOOT_COLOR_COMMON = <192, 192, 192>
const vector LOOT_COLOR_RARE = <RARE_R, RARE_G, RARE_B>
const vector LOOT_COLOR_EPIC = <EPIC_R, EPIC_G, EPIC_B>
const vector LOOT_COLOR_LEGENDARY = <LEGENDARY_R, LEGENDARY_G, LEGENDARY_B>
const vector LOOT_COLOR_HEIRLOOM = <255, 0, 0>
#endif

// use this for in game loot
vector function GetFXRarityColorForTier( int tier )
{
#if SERVER
	//Warning( "Server is attempting to get a loot rarity color. This does not support accessibility features such as color blind mode." )
	switch ( tier )
	{
		case eLootTier.NONE:
			return LOOT_COLOR_NONE

		case eLootTier.COMMON:
			return LOOT_COLOR_COMMON

		case eLootTier.RARE:
			return LOOT_COLOR_RARE

		case eLootTier.EPIC:
			return LOOT_COLOR_EPIC

		case eLootTier.LEGENDARY:
			return LOOT_COLOR_LEGENDARY
			
		case 5:
			return LOOT_COLOR_HEIRLOOM
			
		case 6:
			return <36, 194, 25>
			
		case 7:
			return <191, 25, 194>

		default:
			return <255, 255, 255>
	}
#endif

#if !SERVER
	switch ( tier )
	{
		case 6:
			return <36, 194, 25>
			
		case 7:
			return <191, 25, 194>

		default:
			return GetKeyColor( COLORID_FX_LOOT_TIER0, tier )
	}
#endif

	unreachable
}

// use this for lootbox loot
vector function GetFXRarityColorForUnlockable( int tier )
{
#if SERVER
		Warning( "Server is attempting to get a loot rarity color. This does not support accessibility features such as color blind mode." )
		switch ( tier )
		{
			case eLootTier.NONE:
				return LOOT_COLOR_NONE

			case eLootTier.COMMON:
				return LOOT_COLOR_COMMON

			case eLootTier.RARE:
				return LOOT_COLOR_RARE

			case eLootTier.EPIC:
				return LOOT_COLOR_EPIC

			case eLootTier.LEGENDARY:
				return LOOT_COLOR_LEGENDARY

			case eLootTier.HEIRLOOM:
				return LOOT_COLOR_HEIRLOOM
			
			case 6:
				return <36, 194, 25>
				
			case 7:
				return <191, 25, 194>

			default:
				return <255, 255, 255>
		}
#endif

#if !SERVER
	switch ( tier )
	{
		case 6:
			return <36, 194, 25>
			
		case 7:
			return <191, 25, 194>

		default:
			return GetKeyColor( COLORID_FX_LOOT_TIER0, tier + 1 )
	}
#endif

	unreachable
}

#if CLIENT && DEVELOPER
void function DumpModdedKeyColors( int colorID, float modVal )
{
	for ( int index = 0; index < 6; index++ )
	{
		vector color = ColorPalette_GetColorFromID( colorID + index ) / 255.0
		color = SrgbToLinear( color )
		color *= modVal
		color = LinearToSrgb( color ) * 255.0

		printt( index + ", ", int( color.x ) + " ", int( color.y ) + " ", int( color.z ) )
	}
}
#endif

#if CLIENT && DEVELOPER
void function DiffKeyColors( int baseColorID, int colorID )
{
	var datatable = GetDataTable( $"datatable/colorpalette_table.rpak" )
	for ( int index = 0; index < 6; index++ )
	{
		vector baseColor = ColorPalette_GetColorFromID( baseColorID + index )
		vector otherColor = ColorPalette_GetColorFromID( colorID + index )

		float deltaX = (baseColor.x - otherColor.x) / 255.0
		float deltaY = (baseColor.y - otherColor.y) / 255.0
		float deltaZ = (baseColor.z - otherColor.z) / 255.0

		vector protanColor = GetDataTableVector( datatable, baseColorID + index, 2 )
		vector deuterColor = GetDataTableVector( datatable, baseColorID + index, 3 )
		vector tritanColor = GetDataTableVector( datatable, baseColorID + index, 4 )

		printt( index + ", ", deltaX + " ", deltaY + " ", deltaZ )
	}
}
#endif


bool function SURVIVAL_Loot_IsUniqueAmmoWeapon( string ref )
{
	return file.uniqueAmmoWeaponRefs.contains( ref )
}


#if(UI)
void function SURVIVAL_UIInit_Override_DeathBox_RUI()
{
	if ( !IsConnected() )
		return

	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", 1 ) != 1 )
		return

	if ( !file.overrideDeathBoxRUI_Initialized ) //
	{
		AddUICallback_OnLevelInit( SURVIVAL_UI_OnLevelInit )
		AddCallbackAndCallNow_UserInfoUpdated( HAS_DEATHBOX_OVERRIDE_OnUserInfoUpdated )
	}

	file.overrideDeathBoxRUI_Initialized = true
}
#endif


#if(UI)
void function SURVIVAL_UI_OnLevelInit()
{
	if ( IsLobby() )
	{
		return
	}

	if ( GetCurrentPlaylistVarInt( "enableFlyers", 1 ) != 1 )
		return

	thread SURVIVAL_UI_GatherFriendInfo()
}
#endif

void function AddCallback_OnLootDatatablesLoaded( void functionref() callback )
{
	Assert( !file.lootDatatablesLoadedCallbacks.contains( callback ), "Tried to add a callback that was already added" )

	if( file.lootDatatablesLoadedCallbacks.contains( callback ) )
		return
	
	file.lootDatatablesLoadedCallbacks.append( callback )
}

#if CLIENT || UI
void function AddCallback_EditLootDesc( string functionref( string, entity, string ) callback )
{
	Assert( !file.editLootDescCallbacks.contains( callback ), "Tried to add a callback that was already added" )
	file.editLootDescCallbacks.append( callback )
}
void function RemoveCallback_EditLootDesc( string functionref( string, entity, string ) callback )
{
	Assert( file.editLootDescCallbacks.contains( callback ), "Tried to remove a callback that was not added" )
	file.editLootDescCallbacks.fastremovebyvalue( callback )
}

#endif


#if(UI)
void function SURVIVAL_UI_GatherFriendInfo()
{
	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", 1 ) <= 0 )
		return

	Signal( uiGlobal.signalDummy, "GatherFriendInfo" )
	EndSignal( uiGlobal.signalDummy, "GatherFriendInfo" )
	EndSignal( uiGlobal.signalDummy, "GatheredEnoughFriendInfo" )


	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND ) == 0 )
		return

	file.overrideDeathBoxRUIProfilesTable.clear()
	file.profilesSent = 0

	FriendsData fData = GetFriendsData()

	while( fData.friends.len() > 0 )
	{
		int randomIndex = RandomInt( fData.friends.len() )
		Friend friend   = fData.friends[ randomIndex  ]
		fData.friends.fastremove( randomIndex )

		if ( friend.ingame == true ) //
			continue

		OverrideDeathBoxRUI_NetworkOptimizedStruct profileData

		file.overrideDeathBoxRUIProfilesTable[ friend.hardware + friend.id  ] <- profileData

		CommunityUserInfo ornull cui = GetUserInfo( friend.hardware, friend.id ) //

		if ( !file.overrideDeathBoxRUIProfilesTable[ friend.hardware + friend.id  ].isValid ) //
		{
			wait 2.0 //
		}
	}
}
#endif


#if(UI)
void function HAS_DEATHBOX_OVERRIDE_OnUserInfoUpdated( string hardware, string id )
{
	if ( !IsConnected()  ) //
		return

	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", 1 ) != 1 )
		return

	if ( IsLobby() )
		return

	if ( hardware == "" && id == "" )
		return

	CommunityUserInfo ornull cui = GetUserInfo( hardware, id )

	if ( cui == null )
		return

	if ( !((hardware + id) in file.overrideDeathBoxRUIProfilesTable) ) //
		return

	expect CommunityUserInfo( cui )

	if ( !HasCommunityUserPlayedApex( cui ) )
		return

	if ( file.profilesSent >= GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND ) )
		return

	OverrideDeathBoxRUI_NetworkOptimizedStruct profileData
	profileData.name = cui.name
	profileData.hardware = cui.hardware
	profileData.playerID = cui.uid

	ItemFlavor character               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.CHARACTER, eItemType.character )
	LoadoutEntry characterLoadoutEntry = Loadout_CharacterClass()
	profileData.characterIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( characterLoadoutEntry, character )

	ItemFlavor skin               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.CHARACTER_SKIN, eItemType.character_skin )
	LoadoutEntry skinLoadoutEntry = Loadout_CharacterSkin( character )
	profileData.skinIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( skinLoadoutEntry, skin )

	ItemFlavor frame               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.BANNER_FRAME, eItemType.gladiator_card_frame )
	LoadoutEntry frameLoadoutEntry = Loadout_GladiatorCardFrame( character )
	profileData.frameIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( frameLoadoutEntry, frame )

	ItemFlavor stance               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.BANNER_STANCE, eItemType.gladiator_card_stance )
	LoadoutEntry stanceLoadoutEntry = Loadout_GladiatorCardStance( character )
	profileData.stanceIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( stanceLoadoutEntry, stance )

	ItemFlavor firstBadge               = GetBadgeItemFlavorForCommunityUserInfo( cui, character, 0 )
	LoadoutEntry firstBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 0 )
	profileData.firstBadgeIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( firstBadgeLoadoutEntry, firstBadge )

	int firstBadgeDataInt = GetBadgeDataIntegerFromCommunityUserInfo( cui, 0 )
	profileData.firstBadgeDataInt = firstBadgeDataInt

	ItemFlavor secondBadge               = GetBadgeItemFlavorForCommunityUserInfo( cui, character, 1 )
	LoadoutEntry secondBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 1 )
	profileData.secondBadgeIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( secondBadgeLoadoutEntry, secondBadge )

	int secondBadgeDataInt = GetBadgeDataIntegerFromCommunityUserInfo( cui, 1 )
	profileData.secondBadgeDataInt = secondBadgeDataInt

	ItemFlavor thirdBadge               = GetBadgeItemFlavorForCommunityUserInfo( cui, character, 2 )
	LoadoutEntry thirdBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 2 )
	profileData.thirdBadgeIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( thirdBadgeLoadoutEntry, thirdBadge )

	int thirdBadgeDataInt = GetBadgeDataIntegerFromCommunityUserInfo( cui, 2 )
	profileData.thirdBadgeDataInt = thirdBadgeDataInt

	profileData.isValid = true

	file.overrideDeathBoxRUIProfilesTable[ hardware + id  ] = profileData

	//
	string clientCommandString = "ClientCommand_RUIProfileList "
	clientCommandString += profileData.name
	clientCommandString += " "
	clientCommandString += profileData.hardware
	clientCommandString += " "
	clientCommandString += profileData.playerID
	clientCommandString += " "
	clientCommandString += profileData.characterIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.skinIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.frameIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.stanceIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.firstBadgeIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.firstBadgeDataInt.tostring()
	clientCommandString += " "
	clientCommandString += profileData.secondBadgeIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.secondBadgeDataInt.tostring()
	clientCommandString += " "
	clientCommandString += profileData.thirdBadgeIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.thirdBadgeDataInt.tostring()

	//
	ClientCommand( clientCommandString )

	if ( ++file.profilesSent >= GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND ) )
	{
		Signal( uiGlobal.signalDummy, "GatheredEnoughFriendInfo" ) //
	}
}
#endif

#if SERVER || CLIENT
bool function SURVIVAL_Loot_IsAmmoSpawningDisabled()
{
return GetCurrentPlaylistVarBool( "block_ammo_spawning", false )
}
#endif